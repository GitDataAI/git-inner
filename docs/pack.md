# gitformat-pack(5)


## NAME
 gitformat-pack - Git 打包格式


## SYNOPSIS
 [verse]
 $GIT_DIR/objects/pack/pack-*.{pack,idx}
 $GIT_DIR/objects/pack/pack-*.rev
 $GIT_DIR/objects/pack/pack-*.mtimes
 $GIT_DIR/objects/pack/multi-pack-index


## DESCRIPTION
 Git 打包格式（Git pack format）是 Git 存储其大部分主要仓库数据的方式。在仓库的生命周期中，松散对象（若存在）和较小的打包文件会被合并为一个或多个更大的打包文件。参见 linkgit:git-gc[1]（git-gc 文档）和 linkgit:git-pack-objects[1]（git-pack-objects 文档）。

 该打包格式也用于网络传输（例如参见 linkgit:gitprotocol-v2[5]，gitprotocol-v2 文档），同时也是其他容器格式（如 linkgit:gitformat-bundle[5]，gitformat-bundle 文档）的组成部分。


### 校验和与对象 ID（Checksums and object IDs）
 在使用传统 SHA-1 哈希算法的仓库中，下文提及的打包文件校验和、索引校验和以及对象 ID（对象名）均通过 SHA-1 计算得出。同理，在使用 SHA-256 哈希算法的仓库中，这些值均通过 SHA-256 计算得出。


### pack-*.pack 文件具有以下格式：
    - 开头是文件头，包含以下内容：
      4 字节签名（4-byte signature）：
          签名为：{'P', 'A', 'C', 'K'}
      4 字节版本号（网络字节序，network byte order）：
          Git 目前支持版本号 2 或 3，但仅生成版本 2 的打包文件。
      4 字节打包文件包含的对象数量（网络字节序）
      说明：打包文件的版本号不会超过 4G，包含的对象数量也不会超过 4G。

    - 文件头之后是多个对象条目，每个条目格式如下：
      （非增量表示，undeltified representation）
      n 字节的类型与长度（3 位表示类型，(n-1)*7 + 4 位表示长度）
      压缩数据（compressed data）

      （增量表示，deltified representation）
      n 字节的类型与长度（3 位表示类型，(n-1)*7 + 4 位表示长度）
      若为 OBJ_REF_DELTA 类型，则紧跟基础对象名；若为 OBJ_OFS_DELTA 类型，则紧跟相对于该增量对象在打包文件中位置的负偏移量
      压缩的增量数据（compressed delta data）

      说明：每个对象的长度采用可变长度格式编码，不受 32 位或其他位数的限制。

    - 文件末尾的尾部数据（trailer）记录了上述所有内容的打包文件校验和。


#### 对象类型（Object types）
 有效的对象类型如下：
 - OBJ_COMMIT（1，提交对象）
 - OBJ_TREE（2，树对象）
 - OBJ_BLOB（3，数据对象）
 - OBJ_TAG（4，标签对象）
 - OBJ_OFS_DELTA（6，偏移量增量对象）
 - OBJ_REF_DELTA（7，引用增量对象）

 类型 5 保留用于未来扩展，类型 0 为无效类型。


#### 长度编码（Size encoding）
 本文档中，非负整数的“长度编码”规则如下：从每个字节中，取 7 个最低有效位用于构成最终整数；只要字节的最高有效位为 1，就继续此过程；最高有效位为 0 的字节提供最后 7 位。这些 7 位的片段会被拼接起来，后续片段的权重更高（即后出现的 7 位表示更高位的数值）。

 此长度编码不应与本文档中同样使用的“偏移量编码（offset encoding）”混淆。


#### 增量表示（Deltified representation）
 从概念上讲，Git 只有四种对象类型：提交（commit）、树（tree）、标签（tag）和数据（blob）。但为节省空间，一个对象可存储为另一个“基础对象（base object）”的“增量（delta）”形式。这些增量表示被分配了新的类型（ofs-delta 和 ref-delta），且仅在打包文件中有效。

 ofs-delta 和 ref-delta 均存储用于“重建目标对象”的“增量数据”——即将增量应用于基础对象可得到目标对象。二者的区别在于：ref-delta 直接编码基础对象的 ID；若基础对象与当前对象在同一个打包文件中，ofs-delta 则编码基础对象在该打包文件中的偏移量。

 若基础对象在同一个打包文件中，它也可能以增量形式存储。ref-delta 也可引用打包文件外部的对象（即所谓的“精简打包文件（thin pack）”）。但在磁盘上存储时，打包文件应是自包含的，以避免循环依赖。

 增量数据以“基础对象的大小”和“待重建对象的大小”开头，这两个大小均采用上述“长度编码”规则编码。增量数据的剩余部分是一系列“从基础对象重建目标对象的指令”。若基础对象本身是增量形式，则必须先将其转换为标准形式（canonical form）。每条指令会向目标对象追加数据，直至目标对象构建完成。目前支持两种指令：一种是从基础对象复制字节范围，另一种是插入指令中嵌入的新数据。

 每条指令的长度都是可变的。指令类型由第一个字节的第 7 位（最高位）决定。下文的图示遵循 RFC 1951（Deflate 压缩数据格式）中的约定。


##### 从基础对象复制的指令（Instruction to copy from base object）
   +----------+---------+---------+---------+---------+-------+-------+-------+
   | 1xxxxxxx | offset1 | offset2 | offset3 | offset4 | size1 | size2 | size3 |
   +----------+---------+---------+---------+---------+-------+-------+-------+

 这是用于从基础对象复制字节范围的指令格式，编码了“复制起始偏移量”和“复制字节数”。偏移量和大小均采用小端序（little-endian order）。

 所有偏移量字节和大小字节都是可选的，目的是在编码较小的偏移量或大小时减少指令长度。第一个字节的前 7 位（除最高位外的 7 位）决定后续 7 个字节中哪些存在：若第 0 位为 1，则 offset1 存在；若第 1 位为 1，则 offset2 存在，以此类推。

 注意：更紧凑的指令不会改变偏移量和大小的编码规则。例如，若仅省略 offset2（如下所示），offset3 仍表示第 16-23 位（而非变为 offset2 表示第 8-15 位，即使它紧跟在 offset1 之后）。
   +----------+---------+---------+
   | 10000101 | offset1 | offset3 |
   +----------+---------+---------+

 该指令最紧凑的形式仅占 1 字节（0x80），此时偏移量和大小均被省略，默认值为 0。另有一个例外：大小为 0 时会自动转换为 0x10000。


##### 添加新数据的指令（Instruction to add new data）
   +----------+============+
   | 0xxxxxxx |    data    |
   +----------+============+

 这是无需基础对象即可构建目标对象的指令。后续的 data（数据）会被追加到目标对象中。第一个字节的前 7 位（除最高位外的 7 位）决定数据的字节长度，且该长度必须非零。


##### 保留指令（Reserved instruction）
   +----------+============
   | 00000000 |
   +----------+============

 此指令保留用于未来扩展。


### 原始（版本 1）pack-*.idx 文件具有以下格式：
   - 文件头包含 256 个 4 字节整数（网络字节序）。该表的第 N 项记录了“对象名首字节小于等于 N”的对象在对应打包文件中的数量，此表称为“一级扇出表（first-level fan-out table）”。

   - 文件头之后是排序后的 24 字节条目，每个对象对应一个条目。每个条目包含：
     4 字节整数（网络字节序）：记录该对象在打包文件中的存储位置（从文件开头算起的偏移量）。
     一个对应长度的对象名（object name）。

   - 文件末尾的尾部数据（trailer）包含：
     对应打包文件末尾的打包文件校验和副本。
     上述所有内容的索引校验和（index checksum）。


#### 打包文件索引（Pack Idx）文件结构：
 	--  +--------------------------------+
 扇出表    | fanout[0] = 2（示例）         |-.
 （fanout） +--------------------------------+ |
 	    | fanout[1]                      | |
 	    +--------------------------------+ |
 	    | fanout[2]                      | |
 	    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ |
 	    | fanout[255] = 总对象数         |---.
 	--  +--------------------------------+ | |
 主索引    | 偏移量（offset）               | | |
 （main）   | 对象名 00XXXXXXXXXXXXXXXX     | | |
 索引表    +--------------------------------+ | |
 （index）  | 偏移量                       | | |
 	    | 对象名 00XXXXXXXXXXXXXXXX     | | |
 	    +--------------------------------+<+ |
 	  .-| 偏移量                       |   |
 	  | | 对象名 01XXXXXXXXXXXXXXXX     |   |
 	  | +--------------------------------+   |
 	  | | 偏移量                       |   |
 	  | | 对象名 01XXXXXXXXXXXXXXXX     |   |
 	  | ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~   |
 	  | | 偏移量                       |   |
 	  | | 对象名 FFXXXXXXXXXXXXXXXX     |   |
 	--| +--------------------------------+<--+
 尾部数据   | | 打包文件校验和              |
 （trailer）| +--------------------------------+
 	  | | 索引文件校验和               |
 	  | +--------------------------------+
           .-------.
                   |
 打包文件条目： <+
      打包对象头（packed object header）：
 	1 字节大小扩展位（最高位 MSB）
 	       类型（接下来 3 位）
 	       大小低 4 位（size0）
         n 字节大小扩展位（sizeN）：只要最高位为 1，就继续读取后续字节，每个字节取 7 位
 		size0..sizeN 构成 4 + 7 + 7 + ... + 7 位的整数，size0 是最低有效部分，sizeN 是最高有效部分。
        | S M M M B B B B |
        

      打包对象数据（packed object data）：
         若不是增量对象（DELTA），则为压缩后的字节（上述大小是压缩前的长度）。
 	若为 REF_DELTA 类型：
 	  基础对象名（上述大小是后续增量数据的长度）
           压缩后的增量数据。
 	若为 OFS_DELTA 类型：
 	  n 字节偏移量（见下文说明）：表示相对于该 ofs-delta 条目头中“类型字节”的负偏移量（上述大小是后续增量数据的长度）
 	  压缩后的增量数据。

      偏移量编码（offset encoding）：
 	  除最后一个字节外，其余字节的最高位均为 1。
 	  偏移量的计算方式：拼接每个字节的低 7 位，若 n >= 2，则再加上 2^7 + 2^14 + ... + 2^(7*(n-1)) 的结果。


### 版本 2 的 pack-*.idx 文件支持大于 4GiB 的打包文件，并进行了其他结构调整，格式如下：
   - 4 字节魔数（magic number）'\377tOc'：该值不可能是合理的 fanout[0] 值（用于区分版本 1）。
   - 4 字节版本号（= 2）
   - 256 项扇出表（与版本 1 相同）
   - 对象名排序表：所有对象名打包存储，不包含偏移量，以减少“查找特定对象名时的缓存占用”。
   - 打包对象数据的 4 字节 CRC32 值表：这是版本 2 新增的内容，确保在重新打包时可将压缩数据直接从一个打包文件复制到另一个，且不会出现未检测到的数据损坏。
   - 4 字节偏移量表（网络字节序）：通常是 31 位的打包文件偏移量，但较大的偏移量会被编码为“下一个表的索引”，且最高位（msbit）置 1。
   - 8 字节偏移量条目表（对于小于 2GiB 的打包文件，此表为空）：打包文件会将访问频繁的对象放在靠前位置，因此大多数对象引用无需访问此表。
   - 与版本 1 打包文件相同的尾部数据：
     对应打包文件末尾的打包文件校验和副本。
     上述所有内容的索引校验和。


### pack-*.rev 文件具有以下格式：
   - 4 字节魔数（magic number）'0x52494458'（对应字符 'RIDX'）
   - 4 字节版本标识（= 1）
   - 4 字节哈希函数标识（= 1 表示 SHA-1，= 2 表示 SHA-256）
   - 索引位置表：每个打包对象对应一个条目（总条目数 = 打包文件中的对象数），每个条目是 4 字节无符号整数（网络字节序），按对象在打包文件中的偏移量排序。
   - 尾部数据（trailer）包含：
     对应打包文件的校验和，
     上述所有内容的校验和。

 所有 4 字节数值均采用网络字节序。


### pack-*.mtimes 文件具有以下格式：
 所有 4 字节数值均采用网络字节序。
   - 4 字节魔数（magic number）'0x4d544d45'（对应字符 'MTME'）
   - 4 字节版本标识（= 1）
   - 4 字节哈希函数标识（= 1 表示 SHA-1，= 2 表示 SHA-256）
   - 4 字节无符号整数表：第 i 个值表示对应打包文件中“按字典序（索引序）排序的第 i 个对象”的修改时间（mtime），该时间以标准纪元秒（自 Unix 纪元起的秒数）为单位。
   - 尾部数据（trailer）包含：
     对应打包文件的校验和，
     上述所有内容的校验和（长度由指定的哈希函数决定）。


### multi-pack-index（MIDX，多打包索引）文件具有以下格式：
 多打包索引文件（MIDX）引用多个打包文件和松散对象。为支持“向 MIDX 添加额外数据”的扩展功能，文件主体被组织为“块（chunks）”，并在主体开头提供一个查找表。文件头包含特定的长度信息，如打包文件数量、基础 MIDX 文件数量、哈希长度和哈希类型。

 所有 4 字节数值均采用网络字节序。


#### 头部（HEADER）：
 	4 字节签名（signature）：
 	    签名为：{'M', 'I', 'D', 'X'}
 	1 字节版本号（version number）：
 	    Git 仅写入和识别版本 1。
 	1 字节对象 ID 版本（Object Id Version）：
 	    可从此值推断对象 ID（OID）的长度：
 		1 => SHA-1（长度 20 字节）
 		2 => SHA-256（长度 32 字节）
 	    若该哈希类型与仓库的哈希算法不匹配，则应忽略此多打包索引文件，并向用户显示警告。
 	1 字节“块（chunks）”数量
 	1 字节基础多打包索引文件数量：
 	    此值目前始终为 0。
 	4 字节打包文件数量


#### 块查找表（CHUNK LOOKUP）：
 	(C + 1) * 12 字节，提供块的偏移量：
 	    前 4 字节描述块 ID（chunk id），值为 0 表示终止标记。
 	    后 8 字节提供当前文件中该块的起始偏移量。
 	    （块按文件顺序排列，因此可通过下一个块的位置推断当前块的长度，如有需要）
 	此块查找表符合“基于块的文件格式”中的目录结构，参见 linkgit:gitformat-chunk[5]（gitformat-chunk 文档）。
 	文件主体的剩余数据按“块”逐一描述，这些块可按任意顺序排列。除非另有说明，否则所有块都是必需的。


#### 块数据（CHUNK DATA）：
 	打包文件名块（Packfile Names，ID：{'P', 'N', 'A', 'M'}）：
 	    以“以空字符（NUL）结尾的字符串”序列存储打包文件名。文件名之间无额外填充，且按字典序排列。块的末尾用 0 到 3 个空字符（NUL）填充，使块大小为 4 字节的整数倍。

 	位图打包文件块（Bitmapped Packfiles，ID：{'B', 'T', 'M', 'P'}）：
 	    存储一个“2 个 4 字节无符号整数（网络字节序）”的表。每个表条目对应一个打包文件（按上述 `PNAM` 块中的顺序排列）。每个表条目的值含义如下：
 	    - 该打包文件中的对象在“伪打包顺序（pseudo-pack order，见下文）”中占据的第一个位位置。
 	    - 属于该打包文件的对象所占据的位数。

 	对象 ID 扇出表块（OID Fanout，ID：{'O', 'I', 'D', 'F'}）：
 	    第 i 项 F[i] 存储“首字节小于等于 i”的对象 ID 数量。因此 F[255] 存储的是总对象数。

 	对象 ID 查找表块（OID Lookup，ID：{'O', 'I', 'D', 'L'}）：
 	    MIDX 中所有对象的 ID 按字典序存储在此块中。

 	对象偏移量表块（Object Offsets，ID：{'O', 'O', 'F', 'F'}）：
 	    每个对象存储两个 4 字节值：
 	    1. 存储该对象的打包文件的“整数 ID（pack-int-id）”。
 	    2. 该对象在打包文件中的偏移量。
 		若所有偏移量均小于 2^32，则“大偏移量块（Large Offsets Chunk）”不存在，偏移量按版本 1 索引文件（IDX v1）的格式存储。
 		若至少有一个偏移量大于 2^32 - 1，则“大偏移量块”必须存在，且大于 2^31 - 1 的偏移量需存储在该块中。若“大偏移量块”存在且偏移量的第 31 位为 1，则清除该位后得到的数值即为“大偏移量表中存储该对象 8 字节偏移量的行索引”。

 	[可选] 对象大偏移量表块（Object Large Offsets，ID：{'L', 'O', 'F', 'F'}）：
 	    存储大打包文件（大于 2GiB）的 8 字节偏移量。

 	[可选] 位图打包顺序块（Bitmap pack order，ID：{'R', 'I', 'D', 'X'}）：
 	    存储 MIDX 中每个对象的“MIDX 位置”列表（总条目数 = MIDX 中的对象数），每个条目是 4 字节无符号整数（网络字节序），按“伪打包顺序（pseudo-pack order）”排序。


#### 尾部数据（TRAILER）：
 	上述所有内容的索引校验和。


### 多打包索引反向索引（multi-pack-index reverse indexes）
 与基于单个打包文件的反向索引类似，多打包索引（MIDX）也可用于生成反向索引。

 单个打包文件的反向索引用于映射“偏移量、打包文件、索引位置”，而 MIDX 反向索引则用于映射“对象在 MIDX 中的位置”与“对象在 MIDX 所描述的伪打包文件中的位置”——即 MIDX 反向索引的第 i 项存储的是“伪打包顺序中第 i 个对象在 MIDX 中的位置”。

 为明确两种顺序的区别，可参考 MIDX 可达性位图（目前尚未实现，但以下是其设计方向）：每个位需对应 MIDX 中的一个对象，因此需要一种高效的“位位置到 MIDX 位置”的映射方式。

 一种方案是让“位位置”与 MIDX 中存储的“对象 ID 排序索引”保持一致，但由于对象 ID 本质上是随机的，这种方式生成的可达性位图将缺乏局部性，压缩效率极低（这也是单个打包文件的位图使用“打包文件顺序”而非“.idx 顺序”的原因）。

 因此，我们希望基于“打包文件顺序”为整个 MIDX 定义一种顺序——这种顺序具有更好的局部性，压缩效率更高。可将这种顺序想象为“由 MIDX 中所有打包文件拼接而成的伪打包文件（pseudo-pack）”。例如，若 MIDX 包含 3 个打包文件 a、b、c，分别有 10、15、20 个对象，则伪打包顺序可表示为：
     |a,0|a,1|...|a,9|b,0|b,1|...|b,14|c,0|c,1|...|c,19|
 其中，打包文件的顺序由 MIDX 的打包文件列表定义，每个打包文件内部的对象顺序与该打包文件实际的对象顺序一致。

 已知打包文件列表及其对象数量，理论上可直接重建伪打包顺序（例如，位置 27 的对象必然是 (c,1)，因为打包文件 a 和 b 已占据前 25 个位置）。但存在一个问题：对象可能在多个打包文件中重复，而 MIDX 仅存储该对象的一个引用（因此位图中也只需一个位置）。

 调用方可通过“按位位置顺序读取对象”自行处理重复对象，但这种方式的时间复杂度与对象数量成正比，对于普通的位图查找而言效率过低。构建反向索引可解决此问题——因为反向索引是索引的逻辑逆过程，而索引本身已完成去重。但动态构建反向索引的成本较高，因此我们复用“基于单个打包文件的反向索引”的磁盘格式，用于 MIDX 伪打包文件的反向索引。


 MIDX 中的对象按以下规则排序，以构成伪打包文件：
 定义 `pack(o)` 函数返回“MIDX 为对象 o 选择的打包文件”，并基于“MIDX 存储的打包文件数字 ID”定义打包文件的顺序；定义 `offset(o)` 函数返回“对象 o 在其所属打包文件（pack(o)）中的偏移量”。则对象 o1 和 o2 的排序规则如下：
   - 若 `pack(o1)` 和 `pack(o2)` 中有一个是“优先打包文件（preferred pack）”，另一个不是，则优先打包文件中的对象排在前面。
 +
 （此规则用于 MIDX 位图确定“打包文件复用机制应使用哪个打包文件”——位图可通过查询 MIDX 得到“位位置 0 对应的对象所属的打包文件”。）
   - 若 `pack(o1) ≠ pack(o2)`，则按打包文件 ID 的降序排序。
   - 若 `pack(o1) = pack(o2)`，则按打包文件内的顺序排序（即当 `offset(o1) < offset(o2)` 时，o1 排在 o2 前面）。

 简而言之，MIDX 的伪打包文件是“MIDX 所存储的打包文件中对象的去重拼接”，按“打包文件顺序”排列（优先打包文件排在最前面），每个打包文件内部按“打包文件内对象顺序”排列。

 MIDX 的反向索引存储在 MIDX 内部的可选块 'RIDX' 中。


#### `BTMP` 块
 位图打包文件块（`BTMP`）编码了“多打包索引可达性位图中对象”的额外信息。回顾前文可知，MIDX 中的对象为实现可达性位图，会按“伪打包顺序”排列。

 以上文的示例为例：假设 MIDX 包含打包文件 a、b、c，分别有 10、15、20 个对象，则伪打包顺序如下：
     |a,0|a,1|...|a,9|b,0|b,1|...|b,14|c,0|c,1|...|c,19|

 在处理“单个打包文件位图”或“包含优先打包文件的 MIDX 可达性位图”时，linkgit:git-pack-objects[1]（git-pack-objects 文档）会执行“原样复用（verbatim reuse）”——尝试复用“位图打包文件”或“优先打包文件”的字节块，而非将对象添加到打包列表中。

 当从现有打包文件中复用一个字节块时，该块中包含的所有对象无需添加到打包列表，可节省内存和 CPU 时间。但仅当满足以下条件时，才能复用现有打包文件的字节块：
   - 该块仅包含“调用方请求的对象”（即不包含任何调用方未明确或隐含请求的对象）。
   - 所有以“偏移量增量”或“引用增量”形式存储在“非精简打包文件”中的对象，其基础对象也必须包含在最终生成的打包文件中。

 `BTMP` 块编码了上述“多打包文件复用”所需的信息。具体而言，对于 MIDX 中存储的每个打包文件 p，`BTMP` 块编码了三个信息（均为网络字节序的 32 位无符号整数）：

 `bitmap_pos`:: 多打包索引可达性位图中，属于打包文件 p 的对象所占据的“第一个位位置”（按伪打包顺序）。
 `bitmap_nr`:: 属于打包文件 p 的对象在 bitmap 中占据的“位位置数量”（包含 `bitmap_pos` 对应的位置）。

 例如，上述包含打包文件 a、b、c 的示例中，`BTMP` 块的结构如下：

 [cols="1,2,2"]
 |===
 | |`bitmap_pos`（位起始位置） |`bitmap_nr`（位数量）
 |打包文件 a
 |`0`
 |`10`
 |打包文件 b
 |`10`
 |`15`
 |打包文件 c
 |`25`
 |`20`
 |===

 基于此信息，可像“`BTMP` 块实现前复用单个打包文件”一样，对每个打包文件进行独立复用。


### 冗余打包文件（cruft packs）
 冗余打包文件功能为 Git 提供了一种“替代传统‘删除不可达对象’机制”的方案。本文档将概述 Git 的清理机制（pruning mechanism），以及如何使用冗余打包文件实现相同的目标。


#### 背景（Background）
 要从仓库中删除不可达对象，Git 提供 `git repack -Ad` 命令（参见 linkgit:git-repack[1]，git-repack 文档）。该文档中提到：
 ----
 [...] 之前打包文件中的不可达对象会变为松散对象（loose objects），而非留在旧打包文件中。[...] 松散的不可达对象会在下次执行 `git gc` 时，根据常规的过期规则被清理（pruned）。
 ----

 不可达对象不会被立即删除，因为这可能与“正在进行的推送（push）”产生竞争——推送可能引用即将被删除的对象。因此，这些不可达对象会以松散对象的形式存储，直至超过“过期窗口（expiry window）”，之后会被 linkgit:git-prune[1]（git-prune 文档）删除。

 Git 必须将这些不可达对象以松散形式存储，才能跟踪每个对象的修改时间（mtimes）。若将这些不可达对象写入一个大型打包文件，会导致两个问题：一是“更新打包文件（因其中某个对象被重写）”或“创建新的不可达对象打包文件”时，打包文件的修改时间会被更新，导致其中的对象永远无法超过过期窗口；二是无法跟踪单个对象的修改时间，进而无法按过期规则清理。

 当仓库中存在大量“未超过过期窗口的不可达对象”时，可能出现不良情况：`.git/objects` 目录的分片（shards）中会出现大量文件，导致仓库性能下降；若不可达对象数量过多，还可能导致 inode 耗尽，进而影响整个系统的性能。此外，由于这些对象无法被打包，仓库会占用大量磁盘空间——因为只能通过 zlib 压缩单个对象，无法通过“增量链（delta chains）”进一步节省空间。


#### 冗余打包文件（Cruft packs）
 冗余打包文件通过“在单个打包文件旁附加一个存储‘每个对象修改时间’的独立文件”，消除了“以松散形式存储不可达对象”的需求。

 冗余打包文件由 `git repack --cruft` 命令在生成新打包文件时创建（具体由 linkgit:git-pack-objects[1] 的 `--cruft` 选项实现）。注意，`git repack --cruft` 是“经典的全量打包（all-into-one repack）”——即最终生成的打包文件中包含所有可达对象，其余对象均为不可达对象。执行该命令时，`--cruft` 选项会指示 `git repack` 额外生成一个“仅包含前一步未打包对象（即所有不可达对象）”的打包文件，具体流程如下：
   1. 枚举所有对象，将满足以下条件的对象标记为“遍历起点（traversal tip）”：(a) 不在“保留打包文件（kept-pack）”中；(b) 修改时间（mtime）未超过过期窗口。
   2. 以第一步收集的“遍历起点”为基础，执行可达性遍历，将遍历过程中遇到的所有对象添加到打包列表中。
   3. 写出打包文件，同时生成一个 `.mtimes` 文件，记录每个对象的修改时间。

 此模式由 linkgit:git-repack[1] 在“被指示创建冗余打包文件”时内部调用。关键在于：“内存中的保留打包文件集（in-core kept packs）”恰好是“打包完成后不会被删除的打包文件集”——即这些打包文件包含仓库的所有可达对象。

 当仓库已存在冗余打包文件时，`git repack --cruft` 通常仅向其中添加新对象。一个例外情况是：当 `git repack` 被指定 `--cruft-expiration` 选项时，生成的冗余打包文件会直接省略“已过期的对象”，无需等待后续 `git gc` 清理。

 通常由 linkgit:git-gc[1]（git-gc 文档）负责删除“已过期的不可达对象”。


#### 替代方案（Alternatives）
 该设计的主要替代方案包括：
   - 每个对象修改时间（mtime）数据的存储位置。

 在“修改时间数据的存储位置”方面，选择“与打包文件绑定的新辅助文件（.mtimes）”是为了避免复杂化 `.idx` 格式。若未来 `.idx` 格式支持“可选数据块”，则可考虑将 `.mtimes` 格式合并到 `.idx` 文件中。


## GIT
 ---
 属于 linkgit:git[1]（git 工具集）套件的一部分